getwd()
setwd(select.dir())
setwd(choose.dir())
getwd()
median(x = 1:10)
x
median(x <- 1:10)
x
myNum = 5
myNum <- 5 -> myNum2
print(myNum,myNum2)
myNum = 5
myNum <- 5 -> myNum2
print(cat(myNum,myNum2)
cat(myNum,myNum2)
cat(myNum myNum2)
myNum = 5
myNum <- 5 -> myNum2
cat(c(myNum,myNum2))
print(class(4.5))
print(class(charToRaw("sample")))
print(charToRaw(("sample")))
x <- 5
is.integer(x)
is.numeric(x)
is.matrix(x)
is.data.frame(x)
is.logical(x)
is.vector(x)
is.character(x)
x <- as.integer(x)
x <- 5
is.integer(x)
is.numeric(x)
is.matrix(x)
is.data.frame(x)
is.logical(x)
is.vector(x)
is.character(x)
#convert between data types
x <- as.integer(x)
x <- as.complex(x)
#etc,
x <- as.logical(x)
#etc,
x <- as.logical(x)
x
y
y <- as.logical(0)
y
z <- as.logical(-1)
z
y <- as.numeric(y)
y
z <- as.numeric(z)
z
sprintf("4 + 5 = %d", 4 + 5)
sprintf("4 - 5 = %d", 4 - 5)
sprintf("4 * 5 = %d", 4 * 5)
sprintf("4 / 5 = %d", 4 / 5)
sprintf("4 / 5 = %3f", 4 / 5)
sprintf("4 / 5 = %13f", 4 / 5)
sprintf("4 / 5 = %3f", 4 / 5)
sprintf("4 / 5 = %311f", 4 / 5)
sprintf("4 / 5 = %1.3f", 4 / 5)
sprintf("4 - 5 = %d", 4 - 5)
sprintf("4 - 5 = %1d", 4 - 5)
sprintf("4 - 5 = %2d", 4 - 5)
#% is the format place for the string, 1 is the number of digits before and 3f is the number of digits after the decimal
sprintf("4 / 5 = %.3f", 4 / 5)
#% is the format place for the string, 1 is the number of digits before and 3f is the number of digits after the decimal
sprintf("4 / 5 = %17.3f", 4 / 5)
sprintf("4 * 5 = %.d", 4 * 5)
sprintf("%% %%","test","test")
sprintf("% %","test","test")
sprintf("%% %","test","test")
sprintf("%%","test","test")
sprintf("%s %s","test","test")
#remainder
sprintf("5 %% 4 = %d", 5%%4)
#power is just ^
sprintf("4^2 = %d", 4^2)
#-----------vectors-----------
#defining
numbers = c(1,2,3,4,5)
numbers
numbers
numbers == numbers2
numbers2 <- 1:5
numbers == numbers2
numbers2
numbers == numbers2
class(numbers) == class(numbers2)
#they arent the same apparently
class(numbers)
class(numbers2)
class(numbers3)
numbers3 <- as.numeric(numbers2)
class(numbers3)
class(numbers3) == class(numbers)
#get value from index:
numbers[1]
#get length
length(numbers)
#get last value
numbers[length(numbers)]
#get everything but an index
numbers[-1]
numbers[-1,-2]
numbers[c(-1,-2)]
#get just cetain indices
numbers[c(1,2)]
#get second and third
numbers[2:3]
#sorting, by default sort by increasing
sort(numbers, decreasing = T)
numbers
#but the sort doesnt sort the original number, just returns the list sorted, unless you store it back
numbers = sort(numbers, decreasing = T)
numbers
#generating sequence
sequence1 = 1:10
#generating sequence
seq = 1:10
#generating sequence
add3 = seq(from = 3, to = 27, by = 3)
add3
#what if its different ending, does it stop or error or what?
add3 = seq(from = 3, to = 27, by = 4)
#what if its different ending, does it stop or error or what?
add4 = seq(from = 3, to = 27, by = 4)
add4
#what if its different ending, does it stop or error or what?
add4 = seq(from = 3, to = 28, by = 4)
add4
#what if you just want 10 units?
evens = seq(from = 2, by = 2, length.out = 10)
evens
repeatednonsense
#what if you wanna repeat values?
#print each value in x twice, for a total of 3 times
repeatednonsense = rep(x = c(1,2,3), times = 3, each = 2)
repeatednonsense
sprintf("4 == 5 : %s", 4 == 5)
sprintf("4 != 5 : %s", 4 != 5)
sprintf("4 > 5 : %s", 4 > 5)
sprintf("4 < 5 : %s", 4 < 5)
sprintf("4 >= 5 : %s", 4 >= 5)
sprintf("4 <= 5 : %s", 4 <= 5)
#some tricks with vectors
#creating array of whether even from one to twenty
isEven <- c(1:20) %% 2 == 0
isEven
#creating an array of only evens
oneToTwenty = c(1:20)
evens = oneToTwenty[oneToTwenty %% 2 == 0]
evens
#for new array, take the values inside the one to twenty, that return true
oneToTwenty = oneToTwenty[]
oneToTwenty
#for new array, take the values inside the one to twenty, that return true
oneToTwenty = oneToTwenty[F]
oneToTwenty
#for new array, take the values inside the one to twenty, that return true
oneToTwenty = oneToTwenty[T]
oneToTwenty
#for new array, take the values inside the one to twenty, that return true
oneToTwenty = oneToTwenty[T]
oneToTwenty
oneToTwenty = oneToTwenty[oneToTwenty == 7]
oneToTwenty
#creating an array of only evens
oneToTwenty = c(1:20)
oneToTwenty = oneToTwenty[oneToTwenty == 7]
oneToTwenty
#creating an array of only evens
oneToTwenty = c(1:20)
oneToTwenty = oneToTwenty[T]
oneToTwenty
#testing what happens for two to twenty one
twoToTwentyone = c(2:21)
newevens = twoToTwentyone[twoToTwentyone %% 2 ==0]
newevens
print(twoToTwentyone[3])
print(newstring[1])
newstring = c("hello","konichiwa","I don't know japanese")
print(newstring[1])
#----------logical operators----------
cat("TRUE && FALSE = ", T && F, "\n")
cat("TRUE || FALSE = ", T || F, "\n")
cat("!TRUE = ", !T, "\n")
grade <- "F"
#just did some research, double quotes are preferred because results are printed
#with double quotes, single quotes for delimiters
ans = switch(grade,
"A" = "marvelous, finally pulling your own weight",
"B" = "fine",
"C" = "ok...",
"D" = "hm...",
"E" = "excuse me?",
"F" = "classic philip grade",
"dont lie to me")
print(ans)
grade <- "Z"
#just did some research, double quotes are preferred because results are printed
#with double quotes, single quotes for delimiters
ans = switch(grade,
"A" = "marvelous, finally pulling your own weight",
"B" = "fine",
"C" = "ok...",
"D" = "hm...",
"E" = "excuse me?",
"F" = "classic philip grade",
"dont lie to me")
print(ans)
#number of characters
nchar(str1)
str1 = "this is a string"
#number of characters
nchar(str1)
#comparing strings
sprintf("Dog > Egg : %s", "Dog" > "Egg")
sprintf("Dog == Egg : %s", "Dog" == "Egg")
sprintf("Egg > Dog : %s", "Egg" > "Dog")
